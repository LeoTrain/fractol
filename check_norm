#!/bin/bash

RESET="\033[0m"
RED="\033[0;31m"
GREEN="\033[0;32m"
YELLOW="\033[0;33m"
BLUE="\033[0;34m"
PURPLE="\033[0;35m"
CYAN="\033[0;36m"
WHITE="\033[1;37m"
BOLD="\033[1m"

ROOT_DIR="."

IGNORED_ERRORS=""

total_files=0
passed_files=0
failed_files=0

print_header() {
    echo -e "${BOLD}${CYAN}================================================${RESET}"
    echo -e "${BOLD}${CYAN}           NORMINETTE CHECKER                   "
    echo -e "${BOLD}${CYAN}================================================${RESET}"
    echo ""
}

print_file_status() {
    local file="$1"
    local status="$2"
    local details="$3"
    local filename=$(basename "$file")

    if [ "$status" != "OK" ]; then
        echo -e "${RED}[KO]${RESET} $filename"
        if [ -n "$details" ]; then
            echo -e "${YELLOW}    ${details}${RESET}"
        fi
    fi
}

print_summary() {
    echo ""
    echo -e "${BOLD}${CYAN}================================================${RESET}"
    echo -e "${BOLD}${WHITE}                 SUMMARY${RESET}"
    echo -e "${BOLD}${CYAN}================================================${RESET}"
    echo -e "${BLUE}Total files checked:${RESET} ${total_files}"
    echo -e "${GREEN}Files passed:${RESET}        ${passed_files}"
    echo -e "${RED}Files failed:${RESET}        ${failed_files}"
    echo ""

    if [ $failed_files -eq 0 ]; then
        echo -e "${BOLD}${GREEN}[CORRECT]${RESET} All files respect the norm!"
    else
        echo -e "${BOLD}${RED}[FAILED]${RESET} ${failed_files} file(s) have norm errors"
    fi
    echo -e "${BOLD}${CYAN}================================================${RESET}"
}

main() {
    print_header

    if ! command -v norminette &> /dev/null; then
        echo -e "${RED}[ERROR]${RESET} norminette is not installed or not in PATH"
        echo -e "${YELLOW}[INFO]${RESET} Please install norminette first"
        exit 1
    fi

    echo -e "${YELLOW}[INFO]${RESET} Searching for C and H files..."
    echo ""

    while IFS= read -r file; do
        if [ -z "$file" ]; then
            continue
        fi
        ((total_files++))
        norm_output=$(norminette "$file" 2>&1)

        # Filter out ignored errors only if IGNORED_ERRORS is not empty
        if [ -n "$IGNORED_ERRORS" ]; then
            filtered_output=$(echo "$norm_output" | grep -vE "$IGNORED_ERRORS")
        else
            filtered_output="$norm_output"
        fi

        if echo "$filtered_output" | grep -q "OK!" && ! echo "$filtered_output" | grep -q "Error!"; then
            ((passed_files++))
            print_file_status "$file" "OK"
        else
            ((failed_files++))
            error_details=$(echo "$filtered_output" | grep -v "OK!" | grep -v "^$file:" | head -3)
            print_file_status "$file" "FAIL" "$error_details"
        fi
    done < <(find "$ROOT_DIR" -name "*.c" -o -name "*.h" | sort)
    print_summary
    if [ $failed_files -eq 0 ]; then
        exit 0
    else
        exit 1
    fi
}

main
